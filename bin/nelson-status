#!/bin/bash
# Nelson Status Dashboard - Monitor Nelson Loop progress
# Usage: nelson-status [--watch [interval]] [--prd path/to/prd.json]

REFRESH_INTERVAL=2
WATCH_MODE=false
PRD_FILE=".nelson/prd.json"
PLAN_FILE=".nelson/@IMPLEMENTATION_PLAN.md"
MODE="auto"

# Parse arguments
while [[ $# -gt 0 ]]; do
  case $1 in
    --watch|-w)
      WATCH_MODE=true
      if [[ "$2" =~ ^[0-9]+$ ]]; then
        REFRESH_INTERVAL=$2
        shift
      fi
      shift
      ;;
    --prd)
      PRD_FILE="$2"
      shift 2
      ;;
    --help|-h)
      echo "Usage: nelson-status [--watch [interval]] [--prd path/to/prd.json]"
      echo ""
      echo "Options:"
      echo "  --watch, -w [N]   Auto-refresh every N seconds (default: 2)"
      echo "  --prd PATH        Path to prd.json (default: .nelson/prd.json)"
      echo "  --help, -h        Show this help"
      exit 0
      ;;
    *)
      shift
      ;;
  esac
done

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
GRAY='\033[0;90m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# Inactivity timeout (90 minutes = 5400 seconds)
INACTIVITY_TIMEOUT=5400

# Get last activity timestamp (most recent of file modification or git commit)
get_last_activity() {
  local last_mod=0
  local last_commit=0

  # Last file modification
  local last_modified_file=$(find . -type f -not -path "./.git/*" -not -path "./target/*" -not -path "./.nelson/archive/*" -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | awk '{print $1}')
  if [ -n "$last_modified_file" ]; then
    last_mod=${last_modified_file%.*}
  fi

  # Last git commit
  if git rev-parse --git-dir > /dev/null 2>&1; then
    last_commit=$(git log -1 --format="%ct" 2>/dev/null || echo "0")
  fi

  # Return the more recent of the two
  if [ "$last_mod" -gt "$last_commit" ]; then
    echo "$last_mod"
  else
    echo "$last_commit"
  fi
}

show_status() {
  clear

  # Header
  echo -e "${BLUE}╔════════════════════════════════════════════════════════════════════════╗${NC}"
  echo -e "${BLUE}║${NC}  ${BOLD}Nelson Status Dashboard${NC}                                              ${BLUE}║${NC}"
  echo -e "${BLUE}╚════════════════════════════════════════════════════════════════════════╝${NC}"
  echo ""

  # Auto-detect mode
  if [ -f "$PRD_FILE" ] && [ -f "$PLAN_FILE" ]; then
    MODE="both"
  elif [ -f "$PRD_FILE" ]; then
    MODE="toro"
  elif [ -f "$PLAN_FILE" ]; then
    MODE="plan-build"
  else
    echo -e "${RED}✗ No Nelson files found${NC}"
    echo ""
    echo "Looking for: $PRD_FILE or $PLAN_FILE"
    echo "Run this from your project directory"
    return 1
  fi

  # Parse based on mode
  if [ "$MODE" = "toro" ] || [ "$MODE" = "both" ]; then
    # Toro mode - parse PRD
    PROJECT=$(jq -r '.project // "Unknown"' "$PRD_FILE" 2>/dev/null)
    BRANCH=$(jq -r '.branchName // "Unknown"' "$PRD_FILE" 2>/dev/null)
    TOTAL_STORIES=$(jq '.userStories | length' "$PRD_FILE" 2>/dev/null)
    COMPLETED_STORIES=$(jq '[.userStories[] | select(.passes == true)] | length' "$PRD_FILE" 2>/dev/null)
    REMAINING_STORIES=$((TOTAL_STORIES - COMPLETED_STORIES))

    # Get current task (first incomplete)
    CURRENT_ID=$(jq -r '[.userStories[] | select(.passes == false)][0].id // "NONE"' "$PRD_FILE" 2>/dev/null)
    CURRENT_TITLE=$(jq -r '[.userStories[] | select(.passes == false)][0].title // "All tasks complete!"' "$PRD_FILE" 2>/dev/null)
  else
    # Plan/Build mode - parse @IMPLEMENTATION_PLAN.md
    PROJECT=$(git rev-parse --show-toplevel 2>/dev/null | xargs basename || echo "Unknown")
    BRANCH=$(git branch --show-current 2>/dev/null || echo "Unknown")

    TOTAL_STORIES=$(grep -E "^- \[.\]" "$PLAN_FILE" 2>/dev/null | wc -l || echo "0")
    COMPLETED_STORIES=$(grep -E "^- \[x\]" "$PLAN_FILE" 2>/dev/null | wc -l || echo "0")
    REMAINING_STORIES=$((TOTAL_STORIES - COMPLETED_STORIES))

    # Get current task (first incomplete)
    CURRENT_LINE=$(grep -E "^- \[ \]" "$PLAN_FILE" 2>/dev/null | head -1)
    if [ -n "$CURRENT_LINE" ]; then
      CURRENT_ID="TASK"
      CURRENT_TITLE=$(echo "$CURRENT_LINE" | sed 's/^- \[ \] //')
    else
      CURRENT_ID="NONE"
      CURRENT_TITLE="All tasks complete!"
    fi
  fi

  # Project Info
  echo -e "${CYAN}Mode:${NC}    ${BOLD}$MODE${NC}"
  echo -e "${CYAN}Project:${NC} $PROJECT"
  echo -e "${CYAN}Branch:${NC}  $BRANCH"
  echo ""

  # Current Task
  echo -e "${BOLD}Current Task:${NC}"
  if [ "$CURRENT_ID" = "NONE" ]; then
    echo -e "  ${GREEN}✓ All tasks complete!${NC}"
  else
    echo -e "  ${YELLOW}ID:${NC}     $CURRENT_ID"
    echo -e "  ${YELLOW}Title:${NC}  $CURRENT_TITLE"
  fi
  echo ""

  # Progress
  if [ $TOTAL_STORIES -gt 0 ]; then
    PERCENT=$((COMPLETED_STORIES * 100 / TOTAL_STORIES))
    echo -e "${BOLD}Progress:${NC}"
    echo -e "  Completed: ${GREEN}$COMPLETED_STORIES${NC} / $TOTAL_STORIES (${GREEN}$PERCENT%${NC})"
    echo -e "  Remaining: ${YELLOW}$REMAINING_STORIES${NC}"

    # Progress bar
    BAR_WIDTH=50
    FILLED=$((PERCENT * BAR_WIDTH / 100))
    EMPTY=$((BAR_WIDTH - FILLED))
    printf "  ["
    printf "${GREEN}"
    printf "%${FILLED}s" | tr ' ' '█'
    printf "${GRAY}"
    printf "%${EMPTY}s" | tr ' ' '░'
    printf "${NC}"
    printf "]\n"
  fi
  echo ""

  # Task List
  echo -e "${BOLD}Task List:${NC}"
  echo ""

  if [ "$MODE" = "toro" ] || [ "$MODE" = "both" ]; then
    # Toro task list
    jq -r '.userStories[] | "\(.id)|\(.title)|\(.passes)"' "$PRD_FILE" 2>/dev/null | while IFS='|' read -r id title passes; do
      if [ "$passes" = "true" ]; then
        echo -e "  ${GREEN}✓${NC} $id - ${GRAY}$title${NC}"
      else
        if [ "$id" = "$CURRENT_ID" ]; then
          echo -e "  ${YELLOW}▶${NC} $id - ${BOLD}$title${NC} ${YELLOW}(in progress)${NC}"
        else
          echo -e "  ${BLUE}○${NC} $id - $title"
        fi
      fi
    done
  else
    # Plan/Build task list
    FIRST_INCOMPLETE=true
    grep -E "^- \[.\]" "$PLAN_FILE" 2>/dev/null | while read -r line; do
      if echo "$line" | grep -q "\[x\]"; then
        TASK_TITLE=$(echo "$line" | sed 's/^- \[x\] //')
        echo -e "  ${GREEN}✓${NC} ${GRAY}$TASK_TITLE${NC}"
      else
        TASK_TITLE=$(echo "$line" | sed 's/^- \[ \] //')
        if [ "$FIRST_INCOMPLETE" = true ]; then
          echo -e "  ${YELLOW}▶${NC} ${BOLD}$TASK_TITLE${NC} ${YELLOW}(in progress)${NC}"
          FIRST_INCOMPLETE=false
        else
          echo -e "  ${BLUE}○${NC} $TASK_TITLE"
        fi
      fi
    done
  fi

  echo ""

  # Activity Monitor
  echo -e "${BOLD}Activity:${NC}"

  # Last git commit
  if git rev-parse --git-dir > /dev/null 2>&1; then
    LAST_COMMIT=$(git log -1 --format="%cr: %s" 2>/dev/null || echo "No commits yet")
    LAST_COMMIT_TIME=$(git log -1 --format="%ct" 2>/dev/null || echo "0")
    CURRENT_TIME=$(date +%s)
    TIME_SINCE_COMMIT=$((CURRENT_TIME - LAST_COMMIT_TIME))

    echo -e "  ${CYAN}Last commit:${NC} $LAST_COMMIT"

    # Note if no recent commits (only if tasks remain)
    if [ $TIME_SINCE_COMMIT -gt 300 ] && [ "$REMAINING_STORIES" -gt 0 ]; then
      echo -e "  ${YELLOW}○ No commits in $(($TIME_SINCE_COMMIT / 60)) minutes${NC}"
    fi
  else
    echo -e "  ${GRAY}Not a git repository${NC}"
  fi

  # Last file modification in project (excluding .git and target)
  LAST_MODIFIED=$(find . -type f -not -path "./.git/*" -not -path "./target/*" -not -path "./.nelson/archive/*" -printf '%T@ %p\n' 2>/dev/null | sort -rn | head -1 | awk '{$1=""; print substr($0,2)}')
  if [ -n "$LAST_MODIFIED" ]; then
    LAST_MOD_TIME=$(stat -c %Y "$LAST_MODIFIED" 2>/dev/null || echo "0")
    TIME_SINCE_MOD=$((CURRENT_TIME - LAST_MOD_TIME))

    if [ $TIME_SINCE_MOD -lt 60 ]; then
      echo -e "  ${GREEN}Last modified:${NC} ${LAST_MODIFIED} (${TIME_SINCE_MOD}s ago)"
    elif [ $TIME_SINCE_MOD -lt 300 ]; then
      echo -e "  ${YELLOW}Last modified:${NC} ${LAST_MODIFIED} ($((TIME_SINCE_MOD / 60))m ago)"
    else
      echo -e "  ${RED}Last modified:${NC} ${LAST_MODIFIED} ($((TIME_SINCE_MOD / 60))m ago)${NC}"
    fi
  fi

  # Nelson process check
  if pgrep -f "loop\.sh" > /dev/null 2>&1; then
    NELSON_PID=$(pgrep -f "loop\.sh" | head -1)
    echo -e "  ${GREEN}✓ Nelson running${NC} (PID: $NELSON_PID)"
  else
    echo -e "  ${GRAY}○ Nelson not running${NC}"
  fi

  # Claude process check
  if pgrep -x "claude" > /dev/null 2>&1; then
    CLAUDE_PID=$(pgrep -x "claude" | head -1)
    CLAUDE_CPU=$(ps -p $CLAUDE_PID -o %cpu= 2>/dev/null | xargs)
    CLAUDE_MEM=$(ps -p $CLAUDE_PID -o %mem= 2>/dev/null | xargs)
    echo -e "  ${GREEN}✓ Claude working${NC} (PID: $CLAUDE_PID, CPU: ${CLAUDE_CPU}%, MEM: ${CLAUDE_MEM}%)"
  else
    echo -e "  ${GRAY}○ Claude not running${NC}"
  fi

  echo ""

  # Footer
  if [ "$WATCH_MODE" = true ]; then
    # Calculate time until auto-close
    local last_activity=$(get_last_activity)
    local current=$(date +%s)
    local inactive=$((current - last_activity))
    local remaining=$(((INACTIVITY_TIMEOUT - inactive) / 60))
    if [ "$remaining" -lt 0 ]; then
      remaining=0
    fi
    echo -e "${GRAY}Refreshing every ${REFRESH_INTERVAL}s | Auto-close in ${remaining}m | Ctrl+C to exit${NC}"
  else
    echo -e "${GRAY}Use --watch to auto-refresh${NC}"
  fi
}

# Main loop
if [ "$WATCH_MODE" = true ]; then
  while true; do
    show_status

    # Check for inactivity timeout
    LAST_ACTIVITY=$(get_last_activity)
    CURRENT_TIME=$(date +%s)
    INACTIVE_SECONDS=$((CURRENT_TIME - LAST_ACTIVITY))

    if [ "$INACTIVE_SECONDS" -ge "$INACTIVITY_TIMEOUT" ]; then
      INACTIVE_MINS=$((INACTIVE_SECONDS / 60))
      echo ""
      echo -e "${YELLOW}No activity for ${INACTIVE_MINS} minutes. Auto-closing status watch.${NC}"
      exit 0
    fi

    sleep $REFRESH_INTERVAL
  done
else
  show_status
fi
